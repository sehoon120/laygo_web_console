<% /* eslint-disable */ %>

<%- include('./include/_header') %>

  <main id="site-main" class="container my-4">
    <a href="/main?path=<%= encodeURIComponent(currentPath) %>" class="back-button">
      <i class="fas fa-arrow-left"></i> íŒŒì¼ ëª©ë¡
    </a>
    <div class="row">

      <div class="col-md-6">
        <h2>
          <%= file.filename %>
        </h2>
        <form id="editForm" action="/main/<%= file._id %>/edit?_method=PUT&path=<%= encodeURIComponent(currentPath) %>"
          method="POST">
          <div class="mb-3">
            <textarea name="content" class="form-control" rows="43"
              placeholder="Write your code here"><%= file.content %></textarea>
          </div>
          
          <div class="form-check form-switch mb-3">
            <input class="form-check-input" type="checkbox" id="generateSwitch" name="generate" value="on" form="editForm">
            <label class="form-check-label" for="generateSwitch">Generate (Save í›„ ì‹¤í–‰)</label>
          </div>

          <button type="submit" class="btn btn-primary" form="editForm">Save</button>

          <button id="layoutDrawBtn" type="button" class="btn btn-secondary mt-2">Layout Draw</button>

          </form>
        <div id="message-save" class="msg-box"></div>
        <div id="message-draw" class="msg-box"></div>
      </div>

      <div class="col-md-6">
        <h2>Layout</h2>

        <div class="row">
          <div class="col-md-6">
            <div class="mb-3">
              <label for="yamlFileInput">libname</label>
              <input type="text" id="yamlFileInput" name="yamlFile" class="form-control" placeholder="logic_generated"
                form="editForm">
            </div>
          </div>
          <div class="col-md-6">
            <div class="mb-3">
              <label for="cellNameInput">cellname</label>
              <input type="text" id="cellNameInput" name="cellname" class="form-control" placeholder="cellname"
                form="editForm">
            </div>
          </div>
        </div>

        <div class="text-center">
          <canvas id="canvas" width="770" height="1080" style="border:1px solid #ccc; background:#fff;"></canvas>
        </div>
        <div id="layerToggles" class="layer-toggles"></div>
      </div>

    </div>

    <div id="terminal"
      style="background-color: black; color: lime; font-family: monospace; padding: 10px; height: 300px; overflow-y: auto; margin-top: 20px;">
      </div>
  </main>
  <script>
  document.addEventListener("DOMContentLoaded", function() {

    // ===================== ì „ì—­ ìƒíƒœ ë„¤ì„ìŠ¤í˜ì´ìŠ¤ =====================
    window.layoutState = window.layoutState || {
      rectList: [],
      labelList: [],
      hiddenZ: new Set(),
      canvas: null,
      ctx: null,
      inited: false,
    };

    // ---------- ì•ˆì „ í—¬í¼ ----------
    function R(){ return Array.isArray(layoutState.rectList) ? layoutState.rectList : (layoutState.rectList=[]); }
    function L(){ return Array.isArray(layoutState.labelList) ? layoutState.labelList : (layoutState.labelList=[]); }

    // ===================== ìº”ë²„ìŠ¤ ì´ˆê¸°í™” & ë³€í™˜ ì¶”ì  =====================
    function ensureInit() {
      if (layoutState.inited) return;
      layoutState.canvas = document.getElementById('canvas');
      if (!layoutState.canvas) return;
      layoutState.ctx = layoutState.canvas.getContext('2d');
      trackTransforms(layoutState.ctx);
      layoutState.inited = true;
    }

    function trackTransforms(ctx) {
      const svg = document.createElementNS("http://www.w3.org/2000/svg", 'svg');
      let xform = svg.createSVGMatrix();
      ctx.getTransform = () => xform;

      const saved = [];
      const save = ctx.save; ctx.save = function(){ saved.push(xform.translate(0,0)); return save.call(ctx); };
      const restore = ctx.restore; ctx.restore = function(){ xform = saved.pop() || svg.createSVGMatrix(); return restore.call(ctx); };

      const scale = ctx.scale; ctx.scale = function(sx,sy){ xform = xform.scaleNonUniform(sx,sy); return scale.call(ctx,sx,sy); };
      const rotate = ctx.rotate; ctx.rotate = function(rad){ xform = xform.rotate(rad*180/Math.PI); return rotate.call(ctx,rad); };
      const translate = ctx.translate; ctx.translate = function(dx,dy){ xform = xform.translate(dx,dy); return translate.call(ctx,dx,dy); };
      const transform = ctx.transform; ctx.transform = function(a,b,c,d,e,f){
        const m = svg.createSVGMatrix(); m.a=a;m.b=b;m.c=c;m.d=d;m.e=e;m.f=f;
        xform = xform.multiply(m); return transform.call(ctx,a,b,c,d,e,f);
      };
      const setTransform = ctx.setTransform; ctx.setTransform = function(a,b,c,d,e,f){
        xform.a=a;xform.b=b;xform.c=c;xform.d=d;xform.e=e;xform.f=f; return setTransform.call(ctx,a,b,c,d,e,f);
      };

      const pt = svg.createSVGPoint();
      ctx.transformedPoint = function(x,y){ pt.x=x; pt.y=y; return pt.matrixTransform(xform.inverse()); }
    }

    // ===================== ì¢Œí‘œì¶•(ê°€ì´ë“œ) =====================
    function drawOriginAxes() {
      const ctx = layoutState.ctx; if (!ctx) return;
      ctx.save();
      ctx.strokeStyle = '#000033'; // '#0077cc';
      ctx.lineWidth = 20;
      const LONG = 100000;

      ctx.beginPath();
      ctx.moveTo(385 - LONG, 540);
      ctx.lineTo(385 + LONG, 540);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(385, 540 - LONG);
      ctx.lineTo(385, 540 + LONG);
      ctx.stroke();
      ctx.restore();
    }

    // ===================== ë°”ìš´ë”© ë°•ìŠ¤ ê¸°ë°˜ ì¤Œ-íˆ¬-í• =====================
    function canonicalRect(r){ const [x,y,w,h] = r; return {left:x, top:y+h, width:w, height:-h}; }
    function computeBounds(rects){
      if (!rects || !rects.length) return null;
      let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
      for (const r of rects){
        const c=canonicalRect(r); const right=c.left+c.width, bottom=c.top+c.height;
        if (c.left<minX) minX=c.left; if (c.top<minY) minY=c.top;
        if (right>maxX) maxX=right;  if (bottom>maxY) maxY=bottom;
      }
      return {minX,minY,maxX,maxY,width:maxX-minX,height:maxY-minY};
    }
    function zoomToFit(margin=20){
      const ctx = layoutState.ctx, canvas = layoutState.canvas; if (!ctx||!canvas) return;
      const b = computeBounds(R()); if (!b) return;
      const sx = (canvas.width - margin*2)/Math.max(b.width,1);
      const sy = (canvas.height- margin*2)/Math.max(b.height,1);
      const s  = Math.max(0.1, Math.min(sx,sy));
      ctx.setTransform(1,0,0,1,0,0);
      // ì¢Œìƒë‹¨ì„ marginìœ¼ë¡œ ì˜®ê¸°ê³  së¡œ ìŠ¤ì¼€ì¼
      ctx.translate(margin - b.minX*s, margin - b.minY*s);
      ctx.scale(s,s);
    }

    // ===================== ë ˆì´ì–´ í† ê¸€ UI =====================
    function scanSceneForLayers() {
      const byKind = new Map(), metals = new Map(), vias = new Map();
      for (const r of R()) {
        const kind = r?.[7] || 'unknown';
        const meta = r?.[8] || {};
        const z = meta.z ?? 0;

        if (!byKind.has(kind)) byKind.set(kind, new Set());
        byKind.get(kind).add(z);

        if (kind === 'metal' && meta.layer) {
          metals.set(String(meta.layer), z);
        }
        if (kind === 'via') {
          const k = meta.layerPair || 'via';
          vias.set(String(k), z);
        }
      }
      return { byKind, metals, vias };
    }


    function makeBtn(title, zValues){
      const btn = document.createElement('button');
      btn.className = 'layer-btn on';
      btn.textContent = title;
      btn.title = `toggle ${title}`;
      const anyHidden = zValues.some(z => layoutState.hiddenZ.has(z));
      if (anyHidden) btn.classList.replace('on','off');

      btn.onclick = () => {
        const allHidden = zValues.every(z => layoutState.hiddenZ.has(z));
        if (allHidden) zValues.forEach(z => layoutState.hiddenZ.delete(z));
        else zValues.forEach(z => layoutState.hiddenZ.add(z));
        const nowAnyHidden = zValues.some(z => layoutState.hiddenZ.has(z));
        btn.classList.toggle('on', !nowAnyHidden);
        btn.classList.toggle('off', nowAnyHidden);
        redraw();
      };
      return btn;
    }
    
    // ì´ í•¨ìˆ˜ë¥¼ ìˆ˜ì •í•©ë‹ˆë‹¤
    function buildLayerToggles(containerId='layerToggles'){
        const el = document.getElementById(containerId);
        if (!el) return;
        el.innerHTML = '';
        const { byKind, metals, vias } = scanSceneForLayers();

        const order = ['bbox','subblock','pin'];
        order.forEach(kind=>{
            if (!byKind.has(kind)) return;
            const zs = Array.from(byKind.get(kind));
            
            // ê° ë²„íŠ¼ ê·¸ë£¹ì„ ìœ„í•œ ìƒˆë¡œìš´ divë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
            const groupDiv = document.createElement('div');
            groupDiv.className = 'layer-toggles-row';

            const titleEl = document.createElement('span');
            titleEl.className='layer-group-title';
            titleEl.textContent=kind;
            groupDiv.appendChild(titleEl);

            const allBtn = makeBtn('All', zs);
            allBtn.classList.add('small');
            allBtn.classList.add('wide-btn');
            groupDiv.appendChild(allBtn);
            
            el.appendChild(groupDiv);
        });

        // "metals" ê·¸ë£¹ì„ ìƒˆë¡œìš´ ì¤„ì— ì¶”ê°€
        if (metals.size){
            const metalsDiv = document.createElement('div');
            metalsDiv.className = 'layer-toggles-row';
            
            const titleEl = document.createElement('span');
            titleEl.className='layer-group-title';
            titleEl.textContent='metals';
            metalsDiv.appendChild(titleEl);

            const allZ = Array.from(metals.values());
            const allBtn = makeBtn('All metals', allZ);
            allBtn.classList.add('small');
            metalsDiv.appendChild(allBtn);
            
            const entries = Array.from(metals.entries()).sort((a,b)=>{
                const na = parseInt(String(a[0]).match(/\d+/)?.[0]||'0',10);
                const nb = parseInt(String(b[0]).match(/\d+/)?.[0]||'0',10);
                return na-nb || String(a[0]).localeCompare(String(b[0]));
            });
            for (const [lname,z] of entries){
                metalsDiv.appendChild(makeBtn(lname,[z]));
            }
            el.appendChild(metalsDiv);
        }

        // "vias" ê·¸ë£¹ì„ ìƒˆë¡œìš´ ì¤„ì— ì¶”ê°€
        if (vias.size) {
            const viasDiv = document.createElement('div');
            viasDiv.className = 'layer-toggles-row';

            const titleEl = document.createElement('span');
            titleEl.className = 'layer-group-title';
            titleEl.textContent = 'vias';
            viasDiv.appendChild(titleEl);

            const allViaZ = Array.from(vias.values());
            const allViasBtn = makeBtn('All vias', allViaZ);
            allViasBtn.classList.add('small');
            viasDiv.appendChild(allViasBtn);

            const entries = Array.from(vias.entries()).sort((a,b)=>{
                const pa = a[0].match(/M(\d+)-M(\d+)/i);
                const pb = b[0].match(/M(\d+)-M(\d+)/i);
                const ka = pa ? [parseInt(pa[1],10), parseInt(pa[2],10)] : [999,999];
                const kb = pb ? [parseInt(pb[1],10), parseInt(pb[2],10)] : [999,999];
                return (ka[0]-kb[0]) || (ka[1]-kb[1]) || a[0].localeCompare(b[0]);
            });

            for (const [pairKey, z] of entries) {
                viasDiv.appendChild(makeBtn(pairKey, [z]));
            }
            el.appendChild(viasDiv);
        }
    }


    // ===================== ê·¸ë¦¬ê¸° =====================
    function redraw(){
      ensureInit();
      const ctx = layoutState.ctx, canvas = layoutState.canvas; if (!ctx||!canvas) return;

      // í´ë¦¬ì–´
      ctx.save();
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.restore();

      // ì¢Œí‘œì¶•
      drawOriginAxes();

      // rect ê·¸ë¦¬ê¸° (z ì •ë ¬ + hidden ì ìš©)
      const rects = R().slice().sort((a,b)=>((a?.[8]?.z??0)-(b?.[8]?.z??0)));
      for (const rect of rects){
        const meta = rect?.[8] || {};
        const z = meta.z ?? 0;
        if (layoutState.hiddenZ.has(z)) continue;
        if (!rect[6]) continue;

        const kind = rect[7];
        if (kind === 'subblock') {
          libn = "libname: " + rect[8].instLib;
          celln = "cellname: " + rect[8].instCell;
          // console.log(libncell);
          ctx.fillStyle = 'rgba(135, 206, 235, 0.35)';
          ctx.fillRect(rect[0], rect[1], rect[2], rect[3]);
          ctx.lineWidth = 10;
          ctx.strokeStyle = rect[4];
          ctx.fillStyle = rect[4];
          ctx.strokeRect(rect[0], rect[1], rect[2], rect[3]);
          ctx.font = "400px Verdana";
          ctx.fillText(rect[5], rect[0]+rect[2]/2-200, rect[1]+rect[3]/2-200);
          // ì¢Œìƒë‹¨ì— lib/cell í‘œì‹œ
          ctx.font = "200px Verdana";
          // ctx.textAlign = "left";
          // ctx.textBaseline = "top";
          // í™•ëŒ€/ì¶•ì†Œ ë³´ì •ìš© ì™¸ê³½ì„  ë‘ê»˜
          // const k = (typeof ctx.getTransform === 'function') ? ctx.getTransform().a : 1;
          // const halo = Math.max(1, 6 / Math.max(k, 0.0001));
          ctx.lineWidth = 30; // halo;
          ctx.strokeStyle = "black";
          ctx.fillStyle   = "yellow";
          ctx.strokeText(celln,  rect[0] + 6, rect[1]-20);
          ctx.fillText(celln,  rect[0] + 6, rect[1]-20);
          ctx.strokeText(libn,  rect[0] + 6, rect[1]-20 - 250);
          ctx.fillText(libn,  rect[0] + 6, rect[1]-20 - 250);
        } else if (kind === 'subpin') {
          const meta = rect[8] || {};
          // ë°•ìŠ¤: ì„œë¸Œí•€ ì „ìš© ìƒ‰
          ctx.fillStyle = rect[4] || "rgba(255,165,0,0.45)";
          ctx.fillRect(rect[0], rect[1], rect[2], rect[3]);
          ctx.lineWidth = 2;
          ctx.strokeStyle = "rgba(0,0,0,0.6)";
          ctx.strokeRect(rect[0], rect[1], rect[2], rect[3]);

          // í…ìŠ¤íŠ¸: ê²€ì • í…Œë‘ë¦¬ + ë…¸ë€ ê¸€ì”¨ (ì‘ê²Œ)
          const k = (typeof ctx.getTransform === 'function') ? ctx.getTransform().a : 1;
          const halo = Math.max(1, 2 / Math.max(k, 0.0001));
          const label = meta.termName ? `${meta.instName}.${meta.termName}` : (rect[5] || "");

          ctx.font = "120px Verdana";  // tti
          ctx.textAlign = "left";
          ctx.textBaseline = "top";
          ctx.lineJoin = "round";
          ctx.miterLimit = 2;
          ctx.lineWidth = halo;
          ctx.strokeStyle = "black";
          ctx.fillStyle   = "yellow";

          ctx.strokeText(label, rect[0] + 6, rect[1] + 6);
          ctx.fillText(  label, rect[0] + 6, rect[1] + 6);
        } else if (kind === 'pin') {
          ctx.fillStyle = rect[4];
          ctx.fillRect(rect[0], rect[1], rect[2], rect[3]);
          ctx.fillStyle = 'rgba(255, 0, 0, 1.0)';
          ctx.font = "400px Verdana";
          ctx.fillText(rect[5], rect[0]+rect[2]/2-200, rect[1]+rect[3]/2-200);
        } else {
          ctx.fillStyle = rect[4];
          ctx.fillRect(rect[0], rect[1], rect[2], rect[3]);
        }
      }

      drawLabels();
    }

    function drawLabels(){
      const ctx = layoutState.ctx; if (!ctx) return;
      const labels = L(); if (!labels.length) return;

      const sorted = labels.slice().sort((a,b)=>(a.z??0)-(b.z??0));
      const screenLabels = [], worldLabels = [];
      for (const l of sorted){
        const checkZ = (l.lz != null ? l.lz : l.z);
        if (layoutState.hiddenZ.has(checkZ)) continue;
        if (l?.screen || /^cellname:\s|^libname:\s/i.test(l.text)) screenLabels.push(l);
        else worldLabels.push(l);
      }

      // // worldLabelsë¥¼ ê·¸ë¦¬ê³  ì‹¶ìœ¼ë©´ ì—¬ê¸°ì— êµ¬í˜„ ê°€ëŠ¥
      // if (worldLabels.length) {
      //   ctx.save();
      //   // í˜„ì¬ ë³€í™˜ ìœ ì§€ (í™•ëŒ€/ì´ë™ê³¼ ê°™ì´ ì›€ì§ì´ê²Œ)
      //   for (const l of worldLabels) {
      //     if (!l?.text) continue;

      //     // í™•ëŒ€ìœ¨ì— ê´€ê³„ì—†ì´ ì ë‹¹í•œ ì™¸ê³½ì„  ë‘ê»˜ ìœ ì§€
      //     const k = (typeof ctx.getTransform === 'function') ? ctx.getTransform().a : 1;
      //     const outline = Math.max(1, 2 / Math.max(k, 0.0001));

      //     ctx.font = l.font || "11px sans-serif";
      //     ctx.textAlign = l.align || "left";
      //     ctx.textBaseline = l.baseline || "top";

      //     // ë°ì€ ì™¸ê³½ì„ (halo)
      //     ctx.lineWidth = outline;
      //     ctx.strokeStyle = "rgba(255,255,255,0.85)";
      //     ctx.strokeText(l.text, l.x, l.y);

      //     // ë³¸ë¬¸
      //     ctx.fillStyle = l.fill || "#222";
      //     ctx.fillText(l.text, l.x, l.y);
      //   }
      //   ctx.restore();
      // }

      // -------- í™”ë©´ ê³ ì • ë¼ë²¨(HUD) ----------
      if (screenLabels.length){
        ctx.save();
        ctx.setTransform(1,0,0,1,0,0);
        for (const l of screenLabels){
          if (!l?.text) continue;
          ctx.font = l.font || "11px sans-serif";
          ctx.fillStyle = l.fill || "#222";
          ctx.textAlign = l.align || "left";
          ctx.textBaseline = l.baseline || "top";
          const pad = 4;
          const metrics = ctx.measureText(l.text);
          const w = metrics.width + pad*2;
          const h = parseInt((l.font||"11px").match(/\d+/)?.[0] || "11", 10) + pad*2;
          ctx.fillStyle = l.bg || "rgba(255,255,255,0.7)";
          ctx.fillRect((l.x||10)-pad, (l.y||10)-pad, w, h);
          ctx.fillStyle = l.fill || "#111";
          ctx.fillText(l.text, l.x||10, l.y||10);
        }
        ctx.restore();
      }
    }

    // ===================== buildMap_ver2 (ë‹¨ì¼ cellObj) =====================
    // window.buildMap_ver2 = function(cellObj){
    //   const rectList = R(), labelList = L();
    //   const SCALE = 5;

    //   rectList.length = 0;
    //   labelList.length = 0;

    //   const cellname = cellObj.cellname || "(unknown)";
    //   const libname  = cellObj.libname  || "(unknown)";

    //   const Z = { 
    //   bbox:0, 
    //   subblock:10, 
    //   subpin:10,  // subblockì˜ pin
    //   mask:20, 
    //   metal:30, 
    //   via: 50,
    //   pin:100, 
    //   label:1000 };

    //   function parseMetalIndex(layer=""){
    //     const L = String(layer).toLowerCase().replace(/\s+/g,"");
    //     let m = L.match(/metal\s*([0-9]+)/); if (m && m[1]) return parseInt(m[1],10);
    //     m = L.match(/^m\s*([0-9]+)$/);       if (m && m[1]) return parseInt(m[1],10);
    //     return null;
    //   }
    //   function metalZ(layer){
    //     const idx = parseMetalIndex(layer);
    //     const base = Z.metal, step = 2;
    //     return (idx != null) ? base + (idx-1)*step : base;
    //   }
    //   function metalColor(layer){
    //     if (!layer) return "rgba(0,0,255,0.35)";
    //     const L = String(layer).toLowerCase();
    //     if (L.includes('metal1')) return "rgba(0,128,255,0.35)";
    //     if (L.includes('metal2')) return "rgba(255,128,0,0.35)";
    //     if (L.includes('metal3')) return "rgba(160,32,240,0.35)";
    //     return "rgba(0,0,255,0.35)";
    //   }
    //   function pushRectFromXY(xy,color,label,kind,meta={}){
    //     if (!xy || xy.length!==2) return;
    //     const ox = xy[0][0]*SCALE, oy=xy[0][1]*SCALE;
    //     const w  = (xy[1][0]-xy[0][0])*SCALE;
    //     const h  = (xy[1][1]-xy[0][1])*SCALE;
    //     if (meta.z == null) meta.z = Z[kind] ?? 0;
    //     rectList.push([ox, -oy, w, -h, color, label, true, kind, meta]);
    //     labelList.push({
    //       x:ox+2, y:-(oy)-2, text:label,
    //       font:"11px sans-serif", fill:"#222",
    //       align:"left", baseline:"top",
    //       z:Z.label, lz:meta.z, kind
    //     });
    //   }

      
    //   // via ë ˆì´ì–´(ë°°ì—´/ë¬¸ìì—´)ì—ì„œ ë‚®ì€/ë†’ì€ metal ë²ˆí˜¸ ì¶”ì¶œ
    //   function parseViaPair(layer){
    //     // layer ê°€ ["Metal2","Metal3"] ë˜ëŠ” "Metal2,Metal3" ë“±ì¼ ìˆ˜ ìˆìŒ
    //     let a = [], s = layer;
    //     if (Array.isArray(layer)) a = layer;
    //     else if (typeof layer === 'string') a = layer.split(/[,\s/+-]+/);
    //     else return null;

    //     const nums = a.map(parseMetalIndex).filter(n => Number.isInteger(n));
    //     if (nums.length < 2) return null;
    //     nums.sort((x,y)=>x-y);
    //     return [nums[0], nums[1]];  // [lo, hi]
    //   }

    //   // via ìŒ í‘œì‹œìš© í‚¤/ë¼ë²¨
    //   function viaKey(layer){
    //     const p = parseViaPair(layer);
    //     return p ? `M${p[0]}-M${p[1]}` : 'via';
    //   }

    //   // via z: ê¸ˆì† z ì‚¬ì´ì— ë¼ìš°ê¸° (metalZê°€ 30,32,34â€¦ ì‹ì´ë¼ë©´ ì¤‘ê°„ê°’)
    //   function viaZ(layer){
    //     const p = parseViaPair(layer);
    //     if (!p) return Z.via;  // fallback
    //     const zLo = metalZ(`metal${p[0]}`);
    //     const zHi = metalZ(`metal${p[1]}`);
    //     return Math.min(zLo, zHi) + (Math.abs(zHi - zLo) / 2); // ë‘ metal zì˜ ì¤‘ê°„
    //   }

    //   // via ìƒ‰ìƒ: ìŒë§ˆë‹¤ ë‹¤ë¥¸ í†¤
    //   function viaColor(layer){
    //     const p = parseViaPair(layer);
    //     if (!p) return "rgba(80,80,80,0.8)";
    //     const [lo, hi] = p;
    //     // ê°„ë‹¨ íŒ”ë ˆíŠ¸ ì˜ˆì‹œ
    //     const palette = {
    //       'M1-M2': 'rgba(255,0,0,0.8)',
    //       'M2-M3': 'rgba(0,0,255,0.8)',
    //       'M3-M4': 'rgba(0,255,0,0.8)',
    //       'M4-M5': 'rgba(255,51,153,0.8)'
    //     };
    //     return palette[`M${lo}-M${hi}`] || 'rgba(80,80,80,0.8)';
    //   }

    //   // via í¬ê¸°(ì…€ ì¢Œí‘œ ë‹¨ìœ„) â€” í•„ìš” ì‹œ ìŒë³„ë¡œ ë‹¤ë¥´ê²Œ
    //   function viaSize(layer){
    //     const base = 60;
    //     const p = parseViaPair(layer);
    //     if (!p) return base;
    //     const [lo, hi] = p;
    //     // ì˜ˆ: ë” ë†’ì€ ë ˆë²¨ì¼ìˆ˜ë¡ ì•½ê°„ í¬ê²Œ
    //     return base * (1 + (Math.max(lo,hi)-1)*0.1);
    //   }

    //   // í¬ì¸íŠ¸ ì¤‘ì‹¬ ì‚¬ê°í˜• via ì¶”ê°€
    //   function pushViaAtPoint(pt, label, layer){
    //     if (!Array.isArray(pt) || pt.length<2) return;
    //     const size = viaSize(layer);
    //     const ox = (pt[0] - size/2) * SCALE;
    //     const oy = (pt[1] - size/2) * SCALE;
    //     const w  = size * SCALE;
    //     const h  = size * SCALE;

    //     const meta = {
    //       kind: "via",
    //       layerPair: viaKey(layer),    // "M2-M3"
    //       rawLayer: layer,             // ì›ë³¸(ë°°ì—´/ë¬¸ìì—´)
    //       z: viaZ(layer)
    //     };
    //     rectList.push([ox, -oy, w, -h, viaColor(layer), label, true, "via", meta]);
    //     labelList.push({
    //       x: ox+2, y: -(oy)-2, text: label,
    //       font: "11px sans-serif", fill:"#111",
    //       align:"left", baseline:"top",
    //       z: Z.label, lz: meta.z, kind:"via"
    //     });
    //   }


    //   // êµì²´: local XY(BBox) -> placed(absolute) XY(BBox)
    //   // localXY: [[lx0,ly0],[lx1,ly1]]  (ì„œë¸Œë¸”ë¡ ë¡œì»¬)
    //   // instXY:  [tx, ty]               (ì¸ìŠ¤í„´ìŠ¤ ë°°ì¹˜ ì›ì )
    //   // instBBox:[[bx0,by0],[bx1,by1]]  (ì„œë¸Œë¸”ë¡ bbox; ì›ì  ë³´ì •ìš©)
    //   // tr: "R0" | "MX"
    //   function placeChildBBox(localXY, instXY, instBBox, tr) {
    //     if (!Array.isArray(localXY) || localXY.length !== 2) return null;

    //     const [[lx0, ly0], [lx1, ly1]] = localXY;
    //     const tx = +((instXY && instXY[0]) || 0);
    //     const ty = +((instXY && instXY[1]) || 0);

    //     // bbox ì›ì /ë†’ì´
    //     const bx0 = +((instBBox && instBBox[0] && instBBox[0][0]) || 0);
    //     const by0 = +((instBBox && instBBox[0] && instBBox[0][1]) || 0);
    //     const by1 = +((instBBox && instBBox[1] && instBBox[1][1]) || 0);
    //     const H   = - by1 + by0; // â˜… MX ë³´ì •ì— ë°˜ë“œì‹œ í•„ìš” -> ë” í…ŒìŠ¤íŠ¸ í•„ìš”

    //     // ë¡œì»¬ì„ bbox LLë¡œ ì •ê·œí™”
    //     const x0n = lx0 - bx0, y0n = ly0 - by0;
    //     const x1n = lx1 - bx0, y1n = ly1 - by0;

    //     let x0w, y0w, x1w, y1w;
    //     if (tr === "MX") {
    //       // XëŠ” ê·¸ëŒ€ë¡œ, YëŠ” 'H - y'ë¡œ ë’¤ì§‘ì€ ë’¤ tyë¥¼ ë”í•œë‹¤.
    //       x0w = tx + x0n;  y0w = ty + (H - y0n);  // â˜… ê¸°ì¡´: ty - y0n  (ì˜¤ë¥˜ ì›ì¸)
    //       x1w = tx + x1n;  y1w = ty + (H - y1n);
    //     } else { // R0
    //       x0w = tx + x0n;  y0w = ty + y0n;
    //       x1w = tx + x1n;  y1w = ty + y1n;
    //     }

    //     // ll/ur ì •ë ¬
    //     const llx = Math.min(x0w, x1w);
    //     const lly = Math.min(y0w, y1w);
    //     const urx = Math.max(x0w, x1w);
    //     const ury = Math.max(y0w, y1w);

    //     // console.log("llx");
    //     // console.log(x0w);
    //     // console.log(x1w);
    //     // console.log(llx);
    //     // console.log("lly");
    //     // console.log(y0w);
    //     // console.log(y1w);
    //     // console.log(lly);
    //     // console.log("urx");
    //     // console.log(x0w);
    //     // console.log(x1w);
    //     // console.log(urx);
    //     // console.log("ury");
    //     // console.log(y0w);
    //     // console.log(y1w);
    //     // console.log(urx);

    //     return [[llx, lly], [urx, ury]];
    //   }



    //   // 0) bbox
    //   if (Array.isArray(cellObj.bbox) && cellObj.bbox.length===2){
    //     const [p0,p1] = cellObj.bbox;
    //     const ox=p0[0]*SCALE, oy=p0[1]*SCALE;
    //     const w=(p1[0]-p0[0])*SCALE, h=(p1[1]-p0[1])*SCALE;
    //     rectList.push([ox,-oy,w,-h,"rgba(128,128,128,0.12)","bbox",true,"bbox",{kind:"bbox",z:Z.bbox}]);
    //   }

    //   // 1) metals
    //   if (Array.isArray(cellObj.metals)){
    //     cellObj.metals.forEach((m,i)=>{
    //       const color = metalColor(m.layer);
    //       const label = `${m.layer || "Metal"} #${i}`;
    //       pushRectFromXY(m.xy, color, label, "metal", {layer:m.layer||"", z:metalZ(m.layer)});
    //     });
    //   }

    //   // // 1.5) vias  (ì˜ˆ: [{xy:[x,y], layer:'via1', name:'V1'} ...])
    //   // // vias â€” YAMLì—ì„œ layerê°€ ["Metal2","Metal3"] í˜•íƒœ
    //   // if (Array.isArray(cellObj.vias)) {
    //   //   cellObj.vias.forEach((v, i) => {
    //   //     const key = viaKey(v.layer);              // "M2-M3"
    //   //     const name = v.name || key || `via#${i}`;  // ë¼ë²¨
    //   //     pushViaAtPoint(v.xy, name, v.layer);
    //   //   });
    //   // }

    //   // - ìƒˆ í˜•ì‹: bboxê°€ ì (= [pt]==[pt])ì´ê³  xyê°€ ìˆìŒ â†’ ì  ì¤‘ì‹¬ ì •ì‚¬ê°í˜• via
    //   // - êµ¬ í˜•ì‹: bboxê°€ ë©´ì ì´ ìˆëŠ” ì§ì‚¬ê°í˜• â†’ ê·¸ ë°•ìŠ¤ ê·¸ëŒ€ë¡œ ë Œë”
    //   // - ì˜ˆì™¸: bboxëŠ” ì ì¸ë° xyê°€ ì—†ì„ ë•Œ â†’ bboxì˜ ì ì„ ì‚¬ìš©
    //   if (Array.isArray(cellObj.vias)) {
    //     cellObj.vias.forEach((v, i) => {
    //       const key   = viaKey(v.layer);                   // "M2-M3" ë˜ëŠ” 'via'
    //       const label = v.name || key || `via#${i}`;

    //       const hasBBox = Array.isArray(v.bbox) && v.bbox.length === 2
    //                   && Array.isArray(v.bbox[0]) && Array.isArray(v.bbox[1]);
    //       const hasXY   = Array.isArray(v.xy) && v.xy.length >= 2;

    //       if (hasBBox) {
    //         const [b0, b1] = v.bbox;
    //         const dx = Math.abs(Number(b1[0]) - Number(b0[0]));
    //         const dy = Math.abs(Number(b1[1]) - Number(b0[1]));

    //         if (dx === 0 && dy === 0) {
    //           // ì  via: xyê°€ ìˆìœ¼ë©´ xyë¥¼, ì—†ìœ¼ë©´ bboxì˜ ì ì„ ì‚¬ìš©
    //           const pt = hasXY ? v.xy : b0;
    //           pushViaAtPoint(pt, label, v.layer);
    //         } else {
    //           // êµ¬í˜•: ì§ì‚¬ê°í˜• bbox ê·¸ëŒ€ë¡œ ë Œë” (kind='via', zëŠ” ê¸ˆì† ì‚¬ì´ ì¤‘ê°„ê°’)
    //           const meta = {
    //             kind: "via",
    //             layerPair: viaKey(v.layer),
    //             rawLayer: v.layer,
    //             z: viaZ(v.layer)
    //           };
    //           const color = viaColor(v.layer);
    //           pushRectFromXY(v.bbox, color, label, "via", meta);
    //         }
    //       } else if (hasXY) {
    //         // bboxê°€ ì—†ê³  xyë§Œ ìˆëŠ” ê²½ìš°
    //         pushViaAtPoint(v.xy, label, v.layer);
    //       } else {
    //         // ì¢Œí‘œ ì •ë³´ê°€ ì „í˜€ ì—†ìœ¼ë©´ ìŠ¤í‚µ
    //         console.warn("via skipped (no bbox/xy):", v);
    //       }
    //     });
    //   }

    //   // 2) pins
    //   if (Array.isArray(cellObj.pins)){
    //     cellObj.pins.forEach(p=>{
    //       const name = p.name || p.netname || "pin";
    //       pushRectFromXY(p.xy, "rgba(0,200,0,0.55)", String(name), "pin", {
    //         layer:p.layer||"", netname:p.netname||"", z:Z.pin
    //       });
    //     });
    //   }

    //   // 3) subblocks
    //   if (Array.isArray(cellObj.subblocks)){
    //     cellObj.subblocks.forEach(sb=>{
    //       const instName = sb.name || "(inst)";
    //       const instLib  = sb.libname || "";
    //       const instCell = sb.cellname || "";
    //       const xy       = sb.xy || [0,0];
    //       const tr       = sb.transform || "R0";

    //       const bbox = sb.bbox || cellObj.__libBBoxes?.[`${instLib}:${instCell}`];
    //       if (!bbox || bbox.length!==2){ console.warn("subblock bbox missing; skip:", sb); return; }

    //       const w=(bbox[1][0]-bbox[0][0])*SCALE, h=(bbox[1][1]-bbox[0][1])*SCALE;
    //       let ox=xy[0]*SCALE, oy=xy[1]*SCALE; if (tr==="MX") oy -= h;

    //       rectList.push([ox,-oy,w,-h,"rgba(0,0,0,1.0)",instName,true,"subblock",{
    //         kind:"subblock", instName, instLib, instCell, transform:tr, z:Z.subblock
    //       }]);

    //       L().push({ x:ox+2, y:-(oy)-2,  text:`Inst: ${instName}`, font:"12px sans-serif", fill:"#000",
    //         align:"left", baseline:"top", z:Z.label, lz:Z.subblock, kind:"subblock" });
    //       L().push({ x:ox+2, y:-(oy)-16, text:`Lib: ${instLib}, Cell: ${instCell}`, font:"11px sans-serif", fill:"#444",
    //         align:"left", baseline:"top", z:Z.label, lz:Z.subblock, kind:"subblock" });

          
    //       if (sb.pins && typeof sb.pins === 'object') {
    //         for (const [termName, pinObj] of Object.entries(sb.pins)) {
    //           const localXY = pinObj.bbox;
    //           if (!Array.isArray(localXY) || localXY.length !== 2) continue;

    //           // ë¡œì»¬ â†’ ë°°ì¹˜ ì¢Œí‘œ ë³€í™˜ (ë„¤ê°€ ì¨ë‘” placeChildBBox ì‚¬ìš©)
    //           const placedXY = placeChildBBox(localXY, xy, bbox, tr);
    //           if (!placedXY) continue;

    //           // subpinì€ ì„œë¸Œë¸”ë¡ê³¼ ê°™ì´ í† ê¸€ë˜ë„ë¡ z = Z.subpin(=10)
    //           const label = `${instName}.${termName}`;
    //           pushRectFromXY(
    //             placedXY,
    //             "rgba(255,165,0,0.45)",        // ë°•ìŠ¤ ìƒ‰: ì£¼í™© ë°˜íˆ¬ëª… (ì›í•˜ë©´ ë°”ê¿”ë„ ë¨)
    //             label,
    //             "subpin",                      // â† kindë¥¼ subpinìœ¼ë¡œ
    //             {
    //               instName, instLib, instCell,
    //               termName,
    //               z: Z.subpin,
    //               kindHint: "subpin"
    //             }
    //           );

    //           // (ì„ íƒ) ë¼ë²¨ ì—”íŠ¸ë¦¬ ë³„ë„ë¡œë„ ë„£ê³  ì‹¶ë‹¤ë©´:
    //           labelList.push({
    //             x: placedXY[0][0]*SCALE + 4,
    //             y: -(placedXY[0][1]*SCALE) - 4,
    //             text: termName,
    //             font: "12px sans-serif",
    //             fill: "#111",
    //             align: "left",
    //             baseline: "bottom",
    //             z: Z.label, lz: Z.subpin, kind: "subpin"
    //           });
    //         }
    //       }

    //     });
    //   }

    //   // 4) HUD ë¼ë²¨
    //   L().push({ x:10, y:10, text:`cellname: ${cellname}`, font:"bold 14px sans-serif", fill:"#111", align:"left", baseline:"top", z:Z.label });
    //   L().push({ x:10, y:28, text:`libname: ${libname}`,   font:"12px sans-serif",       fill:"#333", align:"left", baseline:"top", z:Z.label });

    //   // === ëª¨ë‘ ì±„ì› ë‹¤ë©´: ì¤Œ-íˆ¬-í• í›„ ì´ë²¤íŠ¸ ì•Œë¦¼ ===
    //   ensureInit();
    //   zoomToFit(20);
    //   window.dispatchEvent(new CustomEvent('layout:ready'));
    // };

    window.buildMap_ver2 = function(cellObj){
      const rectList = R(), labelList = L();
      const SCALE = 5;

      rectList.length = 0;
      labelList.length = 0;

      const cellname = cellObj.cellname || "(unknown)";
      const libname  = cellObj.libname  || "(unknown)";

      const Z = { 
        bbox:0, 
        subblock:10, 
        subpin:10,  // subblockì˜ pin
        mask:20, 
        metal:30, 
        via: 50,
        pin:100, 
        label:1000 
      };

      // --- NEW: bbox/size í‘œì¤€í™” ---
      // obj.bbox ë˜ëŠ” obj.size(+xy, anchor) â†’ [[x0,y0],[x1,y1]]
      function stdBBox(obj, {defaultXY=[0,0]} = {}) {
        // 1) bbox ê·¸ëŒ€ë¡œ
        if (obj?.bbox && Array.isArray(obj.bbox) && obj.bbox.length === 2) return obj.bbox;

        const s = obj?.size;
        if (s) {
          // 2-A) sizeê°€ "ë‘ ì "ì¸ ê²½ìš°: [[x0,y0],[x1,y1]] â†’ ê·¸ëŒ€ë¡œ bbox ì·¨ê¸‰
          if (
            Array.isArray(s) && s.length === 2 &&
            Array.isArray(s[0]) && s[0].length === 2 &&
            Array.isArray(s[1]) && s[1].length === 2
          ) {
            const x0 = Number(s[0][0]), y0 = Number(s[0][1]);
            const x1 = Number(s[1][0]), y1 = Number(s[1][1]);
            return [[x0, y0], [x1, y1]];
          }

          // 2-B) sizeê°€ í­/ë†’ì´ì¸ ê²½ìš°: [w,h] ë˜ëŠ” [[w,h]]
          const wh = Array.isArray(s) && Array.isArray(s[0]) ? s[0] : s;
          const w = Number(wh?.[0] ?? 0);
          const h = Number(wh?.[1] ?? 0);
          const xy = (Array.isArray(obj.xy) && obj.xy.length===2) ? obj.xy : defaultXY;
          const anchor = obj.anchor || 'll'; // 'll' | 'center' | 'ur'

          let x0 = xy[0], y0 = xy[1];
          if (anchor === 'center') { x0 -= w/2; y0 -= h/2; }
          else if (anchor === 'ur') { x0 -= w;  y0 -= h; }
          return [[x0, y0], [x0 + w, y0 + h]];
        }

        // 3) xyê°€ ë‘ ì ì´ë©´ ê·¸ëŒ€ë¡œ, í•œ ì ì´ë©´ ì -bbox
        if (Array.isArray(obj?.xy)) {
          if (Array.isArray(obj.xy[0]) && obj.xy.length === 2) return obj.xy;
          if (obj.xy.length === 2) { const [x,y]=obj.xy; return [[x,y],[x,y]]; }
        }
        return null;
      }


      function parseMetalIndex(layer=""){
        const L = String(layer).toLowerCase().replace(/\s+/g,"");
        let m = L.match(/metal\s*([0-9]+)/); if (m && m[1]) return parseInt(m[1],10);
        m = L.match(/^m\s*([0-9]+)$/);       if (m && m[1]) return parseInt(m[1],10);
        return null;
      }
      function metalZ(layer){
        const idx = parseMetalIndex(layer);
        const base = Z.metal, step = 2;
        return (idx != null) ? base + (idx-1)*step : base;
      }
      function metalColor(layer){
        if (!layer) return "rgba(0,0,255,0.35)";
        const L = String(layer).toLowerCase();
        if (L.includes('metal1')) return "rgba(0,128,255,0.35)";
        if (L.includes('metal2')) return "rgba(255,128,0,0.35)";
        if (L.includes('metal3')) return "rgba(160,32,240,0.35)";
        return "rgba(0,0,255,0.35)";
      }
      function pushRectFromXY(xy,color,label,kind,meta={}){
        if (!xy || xy.length!==2) return;
        const ox = xy[0][0]*SCALE, oy=xy[0][1]*SCALE;
        const w  = (xy[1][0]-xy[0][0])*SCALE;
        const h  = (xy[1][1]-xy[0][1])*SCALE;
        if (meta.z == null) meta.z = Z[kind] ?? 0;
        rectList.push([ox, -oy, w, -h, color, label, true, kind, meta]);
        labelList.push({
          x:ox+2, y:-(oy)-2, text:label,
          font:"11px sans-serif", fill:"#222",
          align:"left", baseline:"top",
          z:Z.label, lz:meta.z, kind
        });
      }

      // via íŒŒì‹±/í‘œí˜„
      function parseViaPair(layer){
        let a = [];
        if (Array.isArray(layer)) a = layer;
        else if (typeof layer === 'string') a = layer.split(/[,\s/+-]+/);
        else return null;
        const nums = a.map(parseMetalIndex).filter(n => Number.isInteger(n));
        if (nums.length < 2) return null;
        nums.sort((x,y)=>x-y);
        return [nums[0], nums[1]];
      }
      function viaKey(layer){
        const p = parseViaPair(layer);
        return p ? `M${p[0]}-M${p[1]}` : 'via';
      }
      function viaZ(layer){
        const p = parseViaPair(layer);
        if (!p) return Z.via;
        const zLo = metalZ(`metal${p[0]}`);
        const zHi = metalZ(`metal${p[1]}`);
        return Math.min(zLo, zHi) + (Math.abs(zHi - zLo) / 2);
      }
      function viaColor(layer){
        const p = parseViaPair(layer);
        if (!p) return "rgba(80,80,80,0.8)";
        const [lo, hi] = p;
        const palette = {
          'M1-M2': 'rgba(255,0,0,0.8)',
          'M2-M3': 'rgba(0,0,255,0.8)',
          'M3-M4': 'rgba(0,255,0,0.8)',
          'M4-M5': 'rgba(255,51,153,0.8)'
        };
        return palette[`M${lo}-M${hi}`] || 'rgba(80,80,80,0.8)';
      }
      function viaSize(layer){
        const base = 60;
        const p = parseViaPair(layer);
        if (!p) return base;
        const [lo, hi] = p;
        return base * (1 + (Math.max(lo,hi)-1)*0.1);
      }
      // explicitSizeê°€ ìˆìœ¼ë©´ ê·¸ í¬ê¸° ì‚¬ìš©
      function pushViaAtPoint(pt, label, layer, explicitSize){
        if (!Array.isArray(pt) || pt.length<2) return;
        const size = explicitSize ?? viaSize(layer);
        const ox = (pt[0] - size/2) * SCALE;
        const oy = (pt[1] - size/2) * SCALE;
        const w  = size * SCALE;
        const h  = size * SCALE;

        const meta = {
          kind: "via",
          layerPair: viaKey(layer),
          rawLayer: layer,
          z: viaZ(layer)
        };
        rectList.push([ox, -oy, w, -h, viaColor(layer), label, true, "via", meta]);
        labelList.push({
          x: ox+2, y: -(oy)-2, text: label,
          font: "11px sans-serif", fill:"#111",
          align: "left", baseline: "top",
          z: Z.label, lz: meta.z, kind:"via"
        });
      }

      // ë¡œì»¬â†’ë°°ì¹˜ BBox ë°°ì¹˜ (MX ë³´ì • í¬í•¨)
      function placeChildBBox(localXY, instXY, instBBox, tr) {
        if (!Array.isArray(localXY) || localXY.length !== 2) return null;

        const [[lx0, ly0], [lx1, ly1]] = localXY;
        const tx = +((instXY && instXY[0]) || 0);
        const ty = +((instXY && instXY[1]) || 0);

        const bx0 = +((instBBox && instBBox[0] && instBBox[0][0]) || 0);
        const by0 = +((instBBox && instBBox[0] && instBBox[0][1]) || 0);
        const by1 = +((instBBox && instBBox[1] && instBBox[1][1]) || 0);
        const H   = - by1 + by0; // MX ë³´ì •ìš© ë†’ì´

        const x0n = lx0 - bx0, y0n = ly0 - by0;
        const x1n = lx1 - bx0, y1n = ly1 - by0;

        let x0w, y0w, x1w, y1w;
        if (tr === "MX") {
          x0w = tx + x0n;  y0w = ty + (H - y0n);
          x1w = tx + x1n;  y1w = ty + (H - y1n);
        } else { // R0
          x0w = tx + x0n;  y0w = ty + y0n;
          x1w = tx + x1n;  y1w = ty + y1n;
        }

        const llx = Math.min(x0w, x1w);
        const lly = Math.min(y0w, y1w);
        const urx = Math.max(x0w, x1w);
        const ury = Math.max(y0w, y1w);
        return [[llx, lly], [urx, ury]];
      }

      // 0) top-level bbox (size í—ˆìš©)
      const topBBox = stdBBox(cellObj);
      if (topBBox){
        const [p0,p1] = topBBox;
        const ox=p0[0]*SCALE, oy=p0[1]*SCALE;
        const w=(p1[0]-p0[0])*SCALE, h=(p1[1]-p0[1])*SCALE;
        rectList.push([ox,-oy,w,-h,"rgba(128,128,128,0.12)","bbox",true,"bbox",{kind:"bbox",z:Z.bbox}]);
      }

      // 1) metals (size í—ˆìš©)
      if (Array.isArray(cellObj.metals)){
        cellObj.metals.forEach((m,i)=>{
          const color = metalColor(m.layer);
          const label = `${m.layer || "Metal"} #${i}`;
          const box = stdBBox(m);
          if (box) pushRectFromXY(box, color, label, "metal", {layer:m.layer||"", z:metalZ(m.layer)});
        });
      }

      // 1.5) vias (size í—ˆìš©: ì -viaì˜ sizeëŠ” ì •ì‚¬ê°í˜• í•œ ë³€)
      if (Array.isArray(cellObj.vias)) {
        cellObj.vias.forEach((v, i) => {
          const key   = viaKey(v.layer);
          const label = v.name || key || `via#${i}`;

          const vBox    = stdBBox(v);
          const hasBBox = !!vBox;
          const hasXY   = Array.isArray(v.xy) && v.xy.length >= 2;

          if (hasBBox) {
            const [b0, b1] = vBox;
            const dx = Math.abs(Number(b1[0]) - Number(b0[0]));
            const dy = Math.abs(Number(b1[1]) - Number(b0[1]));

            if (dx === 0 && dy === 0) {
              const pt = hasXY ? v.xy : b0;
              const sz = Array.isArray(v.size)
                ? (Array.isArray(v.size[0]) ? v.size[0][0] : v.size[0])
                : undefined;
              pushViaAtPoint(pt, label, v.layer, sz);
            } else {
              const meta = { kind: "via", layerPair: viaKey(v.layer), rawLayer: v.layer, z: viaZ(v.layer) };
              const color = viaColor(v.layer);
              pushRectFromXY(vBox, color, label, "via", meta);
            }
          } else if (hasXY) {
            const sz = Array.isArray(v.size)
              ? (Array.isArray(v.size[0]) ? v.size[0][0] : v.size[0])
              : undefined;
            pushViaAtPoint(v.xy, label, v.layer, sz);
          } else {
            console.warn("via skipped (no bbox/xy):", v);
          }
        });
      }

      // 2) pins (size í—ˆìš©)
      if (Array.isArray(cellObj.pins)){
        cellObj.pins.forEach(p=>{
          const name = p.name || p.netname || "pin";
          const box = stdBBox(p);
          if (box) pushRectFromXY(box, "rgba(0,200,0,0.55)", String(name), "pin", {
            layer:p.layer||"", netname:p.netname||"", z:Z.pin
          });
        });
      }

      // 3) subblocks (size í—ˆìš©) + ë‚´ë¶€ subpin(size í—ˆìš©)
      if (Array.isArray(cellObj.subblocks)){
        cellObj.subblocks.forEach(sb=>{
          const instName = sb.name || "(inst)";
          const instLib  = sb.libname || "";
          const instCell = sb.cellname || "";
          const xy       = sb.xy || [0,0];
          const tr       = sb.transform || "R0";

          const bbox = stdBBox(sb) || cellObj.__libBBoxes?.[`${instLib}:${instCell}`];
          if (!bbox || bbox.length!==2){ console.warn("subblock bbox missing; skip:", sb); return; }

          const w=(bbox[1][0]-bbox[0][0])*SCALE, h=(bbox[1][1]-bbox[0][1])*SCALE;
          let ox=xy[0]*SCALE, oy=xy[1]*SCALE; if (tr==="MX") oy -= h;

          rectList.push([ox,-oy,w,-h,"rgba(0,0,0,1.0)",instName,true,"subblock",{
            kind:"subblock", instName, instLib, instCell, transform:tr, z:Z.subblock
          }]);

          L().push({ x:ox+2, y:-(oy)-2,  text:`Inst: ${instName}`, font:"12px sans-serif", fill:"#000",
            align:"left", baseline:"top", z:Z.label, lz:Z.subblock, kind:"subblock" });
          L().push({ x:ox+2, y:-(oy)-16, text:`Lib: ${instLib}, Cell: ${instCell}`, font:"11px sans-serif", fill:"#444",
            align:"left", baseline:"top", z:Z.label, lz:Z.subblock, kind:"subblock" });

          if (sb.pins && typeof sb.pins === 'object') {
            for (const [termName, pinObj] of Object.entries(sb.pins)) {
              const localXY = stdBBox(pinObj);
              if (!Array.isArray(localXY) || localXY.length !== 2) continue;

              const placedXY = placeChildBBox(localXY, xy, bbox, tr);
              if (!placedXY) continue;

              const label = `${instName}.${termName}`;
              pushRectFromXY(
                placedXY,
                "rgba(255,165,0,0.45)",
                label,
                "subpin",
                { instName, instLib, instCell, termName, z: Z.subpin, kindHint: "subpin" }
              );

              labelList.push({
                x: placedXY[0][0]*SCALE + 4,
                y: -(placedXY[0][1]*SCALE) - 4,
                text: termName,
                font: "12px sans-serif",
                fill: "#111",
                align: "left",
                baseline: "bottom",
                z: Z.label, lz: Z.subpin, kind: "subpin"
              });
            }
          }
        });
      }

      // 4) HUD ë¼ë²¨
      L().push({ x:10, y:10, text:`cellname: ${cellname}`, font:"bold 14px sans-serif", fill:"#111", align:"left", baseline:"top", z:Z.label });
      L().push({ x:10, y:28, text:`libname: ${libname}`,   font:"12px sans-serif",       fill:"#333", align:"left", baseline:"top", z:Z.label });

      // === ëª¨ë‘ ì±„ì› ë‹¤ë©´: ì¤Œ-íˆ¬-í• í›„ ì´ë²¤íŠ¸ ì•Œë¦¼ ===
      ensureInit();
      zoomToFit(20);
      window.dispatchEvent(new CustomEvent('layout:ready'));
    };


    // ===================== ì¬ë Œë” íŠ¸ë¦¬ê±° =====================
    window.addEventListener('layout:ready', ()=>{
      buildLayerToggles('layerToggles');
      redraw();
    });

    // ===================== ë“œë˜ê·¸/íœ  ì¸í„°ë™ì…˜ =====================
    (function attachPanZoom(){
      ensureInit(); const canvas=layoutState.canvas, ctx=layoutState.ctx; if (!canvas||!ctx) return;
      let lastX = canvas.width/2, lastY = canvas.height/2;
      let dragStart=null, dragged=false;
      canvas.addEventListener('mousedown', (e)=>{
        document.body.style.userSelect='none';
        lastX=e.offsetX; lastY=e.offsetY;
        dragStart = ctx.transformedPoint(lastX,lastY);
        dragged=false;
      });
      canvas.addEventListener('mousemove', (e)=>{
        lastX=e.offsetX; lastY=e.offsetY; dragged=true;
        if (dragStart){
          const pt = ctx.transformedPoint(lastX,lastY);
          ctx.translate(pt.x - dragStart.x, pt.y - dragStart.y);
          redraw();
        }
      });
      canvas.addEventListener('mouseup', ()=>{
        dragStart=null;
      });
      const scaleFactor=1.1;
      function zoom(clicks){
        const pt = ctx.transformedPoint(lastX,lastY);
        ctx.translate(pt.x,pt.y);
        const factor = Math.pow(scaleFactor, clicks);
        ctx.scale(factor,factor);
        ctx.translate(-pt.x,-pt.y);
        redraw();
      }
      function handleScroll(evt){
        const delta = evt.wheelDelta ? evt.wheelDelta/40 : (evt.detail ? -evt.detail : 0);
        if (delta){ zoom(delta); evt.preventDefault(); }
        return false;
      }
      canvas.addEventListener('DOMMouseScroll', handleScroll, false);
      canvas.addEventListener('mousewheel', handleScroll, false);
    })();

    // ===================== Layout Draw ë²„íŠ¼: ì„œë²„ í˜¸ì¶œ í›„ ë Œë” =====================
    document.getElementById("layoutDrawBtn").addEventListener("click", async function () {
      const form = document.getElementById("editForm");
      const urlObj = new URL(form.action, window.location.origin);
      const basePath = urlObj.pathname; // "/main/:id/edit"
      const pathParam = urlObj.searchParams.get('path') || '/';
      const drawUrl = `${basePath}/draw?path=${encodeURIComponent(pathParam)}`;

      const formData = new FormData(form);
      const cellFromInput = (document.getElementById("cellNameInput").value || '').trim();
      const libFromInput  = (document.getElementById("yamlFileInput").value  || '').trim();
      formData.set('cellname', cellFromInput);
      formData.set('libname',  libFromInput);

      const body = new URLSearchParams(); for (const p of formData) body.append(p[0], p[1]);

      // const msgEl = document.getElementById("message");
      const msgEl = document.getElementById("message-draw");
      try {
        const response = await fetch(drawUrl, {
          method:'POST', headers:{'Content-Type':'application/x-www-form-urlencoded'},
          body, credentials:'include'
        });
        const result = await response.json();
        console.log("ğŸ¯ Layout Draw ì‘ë‹µ:", result);

        if (response.ok && result.success && result.drawObjectDoc){
          const cellObj = result.drawObjectDoc;
          const libName  = cellObj.libname  || result.resolvedLibname  || 'logic_generated';
          const cellName = cellObj.cellname || result.resolvedCellname || '(unknown cell)';
          msgEl.innerText = `âœ… Layout Draw ì„±ê³µ: ${libName} / ${cellName}`;
          // ë“œë¡œìš° ë©”ì‹œì§€ëŠ” í•­ìƒ ë³´ì´ê²Œ ìœ ì§€ (ì €ì¥ í˜ì´ë“œ íƒ€ì´ë¨¸ì™€ ë…ë¦½)
          msgEl.classList.remove('fade-out');
          msgEl.style.opacity = 1;  // í˜¹ì‹œ ì´ì „ì— 0ì´ì—ˆìœ¼ë©´ ë³µêµ¬

          // ìº”ë²„ìŠ¤ ë°ì´í„° ì´ˆê¸°í™” í›„ build & draw
          layoutState.rectList.length = 0;
          layoutState.labelList.length = 0;
          buildMap_ver2(cellObj);  // ë‚´ë¶€ì—ì„œ zoomToFit + layout:ready ë°œìƒ
        } else {
          msgEl.innerText = result?.message || 'âš ï¸ Layout Draw ì‹¤íŒ¨';
          msgEl.classList.remove('fade-out');
          msgEl.style.opacity = 1;
        }
      } catch (err) {
        console.error("âŒ Layout Draw ì˜¤ë¥˜:", err);
        msgEl.innerText = "ì„œë²„ ì˜¤ë¥˜ë¡œ Layoutì„ ê·¸ë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.";
        msgEl.classList.remove('fade-out');
        msgEl.style.opacity = 1;
      }
    });

    // ===================== Save(ì €ì¥) AJAXëŠ” ê¸°ì¡´ ë¡œì§ ìœ ì§€ =====================
    document.getElementById("editForm").addEventListener("submit", async function (e) {
      e.preventDefault();
      const form = e.target;
      const formData = new FormData(form);
      const data = new URLSearchParams(); for (const p of formData) data.append(p[0], p[1]);

      // const msg = document.getElementById("message");
      const msg = document.getElementById("message-save");
      try{
        const response = await fetch(form.action, {
          method:'PUT', headers:{'Content-Type':'application/x-www-form-urlencoded'},
          body:data, credentials:'include'
        });
        const result = await response.json();
        if (response.ok && result.success){
          const generateSwitch = document.getElementById("generateSwitch");
          if(result.fileTypeIsPy === false){
            msg.innerText = "Python scriptë§Œ generationì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.";
          }else{
            msg.innerText = (generateSwitch && generateSwitch.checked) ? "Generate ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤." : "ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.";
          }
        }else{
          msg.innerText = "ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.";
        }
        // msg.style.opacity=1;
        // setTimeout(()=>{ msg.style.transition="opacity 0.5s"; msg.style.opacity=0;}, 2000);
        // ì €ì¥ ë©”ì‹œì§€ì—ë§Œ í˜ì´ë“œì•„ì›ƒ í´ë˜ìŠ¤ ì ìš©
        msg.classList.remove('fade-out');   // ë³´ì—¬ì£¼ê¸°
        // ì—°ì† í´ë¦­ ëŒ€ë¹„: ì´ì „ íƒ€ì´ë¨¸ ì·¨ì†Œ
        if (msg._fadeTimer) { clearTimeout(msg._fadeTimer); msg._fadeTimer = null; }
        msg._fadeTimer = setTimeout(() => {
          msg.classList.add('fade-out');    // ì²œì²œíˆ ì‚¬ë¼ì§
          msg._fadeTimer = null;
        }, 2000);
      }catch(err){
        console.error(err);
        msg.innerText="ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.";
        // msg.style.opacity=1;
        // setTimeout(()=>{ msg.style.transition="opacity 0.5s"; msg.style.opacity=0;}, 2000);
        msg.classList.remove('fade-out');
        if (msg._fadeTimer) { clearTimeout(msg._fadeTimer); msg._fadeTimer = null; }
        msg._fadeTimer = setTimeout(() => {
          msg.classList.add('fade-out');
          msg._fadeTimer = null;
        }, 2000);
      }
    });

    // ===================== ë¡œê·¸ í´ë§ (ê¸°ì¡´ ìœ ì§€) =====================
    setInterval(async () => {
      try {
        const fileId = "<%= file._id %>";
        const res = await fetch(`/main/${fileId}/edit/logs`, { credentials:'include' });
        if (!res.ok) return;
        const text = await res.text();
        try{
          const result = JSON.parse(text);
          document.getElementById("terminal").innerText = result.log;
        }catch(e){ console.error("JSON íŒŒì‹± ì—ëŸ¬:", e); }
      } catch (e) { console.error("ë¡œê·¸ í´ë§ ì—ëŸ¬:", e); }
    }, 2000);

  });
  </script>




  

  <%- include('./include/_footer') %>