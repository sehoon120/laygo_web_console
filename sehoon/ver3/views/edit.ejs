<% /* eslint-disable */ %>

<%- include('./include/_header') %>

  <!-- ÌååÏùº Î™©Î°ùÏúºÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞ Î≤ÑÌäº (ÏôºÏ™Ω ÏÉÅÎã®) -->

  <!-- ==================================================================================================== -->

  <!-- Main -->
  <main id="site-main" class="container my-4">
    <a href="/main?path=<%= encodeURIComponent(currentPath) %>" class="back-button">
      <i class="fas fa-arrow-left"></i> ÌååÏùº Î™©Î°ù
    </a>
    <div class="row">

      <!-- ÏôºÏ™Ω ÏòÅÏó≠: Í∏Ä ÏûëÏÑ± -->
      <div class="col-md-6">
        <h2>
          <%= file.filename %>
        </h2>
        <form id="editForm" action="/main/<%= file._id %>/edit?_method=PUT&path=<%= encodeURIComponent(currentPath) %>"
          method="POST">
          <div class="mb-3">
            <!-- textareaÏóê Í∏∞Î≥∏ file.content Í∞í Ï±ÑÏõåÎÑ£Í∏∞ -->
            <textarea name="content" class="form-control" rows="48"
              placeholder="Write your code here"><%= file.content %></textarea>
          </div>
          <!-- ‚úÖ Generate Ïä§ÏúÑÏπò Ï∂îÍ∞Ä -->
          <div class="form-check form-switch mb-3">
            <input class="form-check-input" type="checkbox" id="generateSwitch" name="generate" value="on" form="editForm">
            <label class="form-check-label" for="generateSwitch">Generate (Save ÌõÑ Ïã§Ìñâ)</label>
          </div>

          <!-- ‚úÖ Save Î≤ÑÌäº ÏàòÏ†ï -->
          <button type="submit" class="btn btn-primary" form="editForm">Save</button>

          <!-- ‚úÖ Layout Draw Î≤ÑÌäº Î∂ÑÎ¶¨ -->
          <button id="layoutDrawBtn" type="button" class="btn btn-secondary mt-2">Layout Draw</button>

          <!-- <button type="submit" class="btn btn-primary">Save & Generate</button> -->
        </form>
        <!-- Ï†ÄÏû• Í≤∞Í≥º Î©îÏãúÏßÄ Ï∂úÎ†• ÏòÅÏó≠ -->
        <div id="message" class="mt-3"></div>
      </div>

      <!-- Ïò§Î•∏Ï™Ω ÏòÅÏó≠: Ïù¥ÎØ∏ÏßÄ ÌëúÏãú Î∞è Ï∂îÍ∞Ä ÏûÖÎ†•ÎûÄ -->
      <div class="col-md-6">
        <h2>Layout</h2>

        <!-- Ïò§Î•∏Ï™Ω ÏÉÅÎã®Ïóê ÏûÖÎ†•ÎûÄ Ï∂îÍ∞Ä -->
        <div class="row">
          <div class="col-md-6">
            <div class="mb-3">
              <label for="yamlFileInput">libname</label>
              <input type="text" id="yamlFileInput" name="yamlFile" class="form-control" placeholder="logic_generated"
                form="editForm">
            </div>
          </div>
          <div class="col-md-6">
            <div class="mb-3">
              <label for="cellNameInput">cellname</label>
              <input type="text" id="cellNameInput" name="cellname" class="form-control" placeholder="cellname"
                form="editForm">
            </div>
          </div>
        </div>

        <div class="text-center">
          <!-- Í∏∞Ï°¥ Ïù¥ÎØ∏ÏßÄ ÎåÄÏã† Ï∫îÎ≤ÑÏä§ Ï∂îÍ∞Ä -->
          <canvas id="canvas" width="770" height="1080" style="border:1px solid #ccc; background:#fff;"></canvas>
        </div>
        <!-- Î†àÏù¥Ïñ¥ ÌÜ†Í∏Ä Î≤ÑÌäºÎì§Ïù¥ Îì§Ïñ¥Í∞à ÏûêÎ¶¨ -->
        <div id="layerToggles" class="layer-toggles"></div>
      </div>

    </div>

    <!-- ÌÑ∞ÎØ∏ÎÑê ÏòÅÏó≠: Î°úÍ∑∏ ÌååÏùº ÎÇ¥Ïö©ÏùÑ ÌëúÏãú -->
    <div id="terminal"
      style="background-color: black; color: lime; font-family: monospace; padding: 10px; height: 300px; overflow-y: auto; margin-top: 20px;">
      <!-- Î°úÍ∑∏ ÎÇ¥Ïö©Ïù¥ Ïó¨Í∏∞Ïóê ÌëúÏãúÎê©ÎãàÎã§ -->
    </div>
  </main>
  <!-- /Main -->


  <!-- ==================================================================================================== -->

  <!-- Ï∫îÎ≤ÑÏä§ Í∏∞Îä• Í¥ÄÎ†® Ïä§ÌÅ¨Î¶ΩÌä∏ Ï∂îÍ∞Ä -->
  <script>
  document.addEventListener("DOMContentLoaded", function() {

    // ===================== Ï†ÑÏó≠ ÏÉÅÌÉú ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ =====================
    window.layoutState = window.layoutState || {
      rectList: [],
      labelList: [],
      hiddenZ: new Set(),
      canvas: null,
      ctx: null,
      inited: false,
    };

    // ---------- ÏïàÏ†Ñ Ìó¨Ìçº ----------
    function R(){ return Array.isArray(layoutState.rectList) ? layoutState.rectList : (layoutState.rectList=[]); }
    function L(){ return Array.isArray(layoutState.labelList) ? layoutState.labelList : (layoutState.labelList=[]); }

    // ===================== Ï∫îÎ≤ÑÏä§ Ï¥àÍ∏∞Ìôî & Î≥ÄÌôò Ï∂îÏ†Å =====================
    function ensureInit() {
      if (layoutState.inited) return;
      layoutState.canvas = document.getElementById('canvas');
      if (!layoutState.canvas) return;
      layoutState.ctx = layoutState.canvas.getContext('2d');
      trackTransforms(layoutState.ctx);
      layoutState.inited = true;
    }

    function trackTransforms(ctx) {
      const svg = document.createElementNS("http://www.w3.org/2000/svg", 'svg');
      let xform = svg.createSVGMatrix();
      ctx.getTransform = () => xform;

      const saved = [];
      const save = ctx.save; ctx.save = function(){ saved.push(xform.translate(0,0)); return save.call(ctx); };
      const restore = ctx.restore; ctx.restore = function(){ xform = saved.pop() || svg.createSVGMatrix(); return restore.call(ctx); };

      const scale = ctx.scale; ctx.scale = function(sx,sy){ xform = xform.scaleNonUniform(sx,sy); return scale.call(ctx,sx,sy); };
      const rotate = ctx.rotate; ctx.rotate = function(rad){ xform = xform.rotate(rad*180/Math.PI); return rotate.call(ctx,rad); };
      const translate = ctx.translate; ctx.translate = function(dx,dy){ xform = xform.translate(dx,dy); return translate.call(ctx,dx,dy); };
      const transform = ctx.transform; ctx.transform = function(a,b,c,d,e,f){
        const m = svg.createSVGMatrix(); m.a=a;m.b=b;m.c=c;m.d=d;m.e=e;m.f=f;
        xform = xform.multiply(m); return transform.call(ctx,a,b,c,d,e,f);
      };
      const setTransform = ctx.setTransform; ctx.setTransform = function(a,b,c,d,e,f){
        xform.a=a;xform.b=b;xform.c=c;xform.d=d;xform.e=e;xform.f=f; return setTransform.call(ctx,a,b,c,d,e,f);
      };

      const pt = svg.createSVGPoint();
      ctx.transformedPoint = function(x,y){ pt.x=x; pt.y=y; return pt.matrixTransform(xform.inverse()); }
    }

    // ===================== Ï¢åÌëúÏ∂ï(Í∞ÄÏù¥Îìú) =====================
    function drawOriginAxes() {
      const ctx = layoutState.ctx; if (!ctx) return;
      ctx.save();
      ctx.strokeStyle = '#0077cc';
      ctx.lineWidth = 20;
      const LONG = 100000;

      ctx.beginPath();
      ctx.moveTo(385 - LONG, 540);
      ctx.lineTo(385 + LONG, 540);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(385, 540 - LONG);
      ctx.lineTo(385, 540 + LONG);
      ctx.stroke();
      ctx.restore();
    }

    // ===================== Î∞îÏö¥Îî© Î∞ïÏä§ Í∏∞Î∞ò Ï§å-Ìà¨-Ìïè =====================
    function canonicalRect(r){ const [x,y,w,h] = r; return {left:x, top:y+h, width:w, height:-h}; }
    function computeBounds(rects){
      if (!rects || !rects.length) return null;
      let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
      for (const r of rects){
        const c=canonicalRect(r); const right=c.left+c.width, bottom=c.top+c.height;
        if (c.left<minX) minX=c.left; if (c.top<minY) minY=c.top;
        if (right>maxX) maxX=right;  if (bottom>maxY) maxY=bottom;
      }
      return {minX,minY,maxX,maxY,width:maxX-minX,height:maxY-minY};
    }
    function zoomToFit(margin=20){
      const ctx = layoutState.ctx, canvas = layoutState.canvas; if (!ctx||!canvas) return;
      const b = computeBounds(R()); if (!b) return;
      const sx = (canvas.width - margin*2)/Math.max(b.width,1);
      const sy = (canvas.height- margin*2)/Math.max(b.height,1);
      const s  = Math.max(0.1, Math.min(sx,sy));
      ctx.setTransform(1,0,0,1,0,0);
      // Ï¢åÏÉÅÎã®ÏùÑ marginÏúºÎ°ú ÏòÆÍ∏∞Í≥† sÎ°ú Ïä§ÏºÄÏùº
      ctx.translate(margin - b.minX*s, margin - b.minY*s);
      ctx.scale(s,s);
    }

    // ===================== Î†àÏù¥Ïñ¥ ÌÜ†Í∏Ä UI =====================
    function scanSceneForLayers(){
      const byKind = new Map(), metals = new Map();
      for (const r of R()){
        const kind = r?.[7] || 'unknown';
        const meta = r?.[8] || {};
        const z = meta.z ?? 0;
        if (!byKind.has(kind)) byKind.set(kind,new Set());
        byKind.get(kind).add(z);
        if (kind==='metal'){
          const lname = (meta.layer||'').toString();
          if (lname) metals.set(lname, z);
        }
      }
      return { byKind, metals };
    }

    function makeBtn(title, zValues){
      const btn = document.createElement('button');
      btn.className = 'layer-btn on';
      btn.textContent = title;
      btn.title = `toggle ${title}`;
      const anyHidden = zValues.some(z => layoutState.hiddenZ.has(z));
      if (anyHidden) btn.classList.replace('on','off');

      btn.onclick = () => {
        const allHidden = zValues.every(z => layoutState.hiddenZ.has(z));
        if (allHidden) zValues.forEach(z => layoutState.hiddenZ.delete(z));
        else zValues.forEach(z => layoutState.hiddenZ.add(z));
        const nowAnyHidden = zValues.some(z => layoutState.hiddenZ.has(z));
        btn.classList.toggle('on', !nowAnyHidden);
        btn.classList.toggle('off', nowAnyHidden);
        redraw();
      };
      return btn;
    }

    function buildLayerToggles(containerId='layerToggles'){
      const el = document.getElementById(containerId); if (!el) return;
      el.innerHTML = '';
      const { byKind, metals } = scanSceneForLayers();

      const order = ['bbox','subblock','mask','pin'];  // ,'metal'
      order.forEach(kind=>{
        if (!byKind.has(kind)) return;
        const zs = Array.from(byKind.get(kind));
        const titleEl = document.createElement('span');
        titleEl.className='layer-group-title';
        titleEl.textContent=kind;
        el.appendChild(titleEl);

        const allBtn = makeBtn('All', zs);
        allBtn.classList.add('small');
        el.appendChild(allBtn);
        el.appendChild(document.createTextNode(' '));
      });

      el.appendChild(document.createElement('div'));

      if (metals.size){
        const titleEl = document.createElement('span');
        titleEl.className='layer-group-title';
        titleEl.textContent='metals';
        el.appendChild(titleEl);

        const allZ = Array.from(metals.values());
        const allBtn = makeBtn('All metals', allZ);
        allBtn.classList.add('small');
        el.appendChild(allBtn);

        const entries = Array.from(metals.entries()).sort((a,b)=>{
          const na = parseInt(String(a[0]).match(/\d+/)?.[0]||'0',10);
          const nb = parseInt(String(b[0]).match(/\d+/)?.[0]||'0',10);
          return na-nb || String(a[0]).localeCompare(String(b[0]));
        });
        for (const [lname,z] of entries){
          el.appendChild(makeBtn(lname,[z]));
        }
      }
    }

    // ===================== Í∑∏Î¶¨Í∏∞ =====================
    function redraw(){
      ensureInit();
      const ctx = layoutState.ctx, canvas = layoutState.canvas; if (!ctx||!canvas) return;

      // ÌÅ¥Î¶¨Ïñ¥
      ctx.save();
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.restore();

      // Ï¢åÌëúÏ∂ï
      drawOriginAxes();

      // rect Í∑∏Î¶¨Í∏∞ (z Ï†ïÎ†¨ + hidden Ï†ÅÏö©)
      const rects = R().slice().sort((a,b)=>((a?.[8]?.z??0)-(b?.[8]?.z??0)));
      for (const rect of rects){
        const meta = rect?.[8] || {};
        const z = meta.z ?? 0;
        if (layoutState.hiddenZ.has(z)) continue;
        if (!rect[6]) continue;

        const kind = rect[7];
        if (kind === 'subblock') {
          ctx.fillStyle = 'rgba(135, 206, 235, 0.35)';
          ctx.fillRect(rect[0], rect[1], rect[2], rect[3]);
          ctx.lineWidth = 10;
          ctx.strokeStyle = rect[4];
          ctx.fillStyle = rect[4];
          ctx.strokeRect(rect[0], rect[1], rect[2], rect[3]);
          ctx.font = "400px Verdana";
          ctx.fillText(rect[5], rect[0]+rect[2]/2-200, rect[1]+rect[3]/2-200);
        } else if (kind === 'pin') {
          ctx.fillStyle = rect[4];
          ctx.fillRect(rect[0], rect[1], rect[2], rect[3]);
          ctx.fillStyle = 'rgba(255, 0, 0, 1.0)';
          ctx.font = "400px Verdana";
          ctx.fillText(rect[5], rect[0]+rect[2]/2-200, rect[1]+rect[3]/2-200);
        } else {
          ctx.fillStyle = rect[4];
          ctx.fillRect(rect[0], rect[1], rect[2], rect[3]);
        }
      }

      drawLabels();
    }

    function drawLabels(){
      const ctx = layoutState.ctx; if (!ctx) return;
      const labels = L(); if (!labels.length) return;

      const sorted = labels.slice().sort((a,b)=>(a.z??0)-(b.z??0));
      const screenLabels = [], worldLabels = [];
      for (const l of sorted){
        const checkZ = (l.lz != null ? l.lz : l.z);
        if (layoutState.hiddenZ.has(checkZ)) continue;
        if (l?.screen || /^cellname:\s|^libname:\s/i.test(l.text)) screenLabels.push(l);
        else worldLabels.push(l);
      }

      // worldLabelsÎ•º Í∑∏Î¶¨Í≥† Ïã∂ÏúºÎ©¥ Ïó¨Í∏∞Ïóê Íµ¨ÌòÑ Í∞ÄÎä•

      if (screenLabels.length){
        ctx.save();
        ctx.setTransform(1,0,0,1,0,0);
        for (const l of screenLabels){
          if (!l?.text) continue;
          ctx.font = l.font || "11px sans-serif";
          ctx.fillStyle = l.fill || "#222";
          ctx.textAlign = l.align || "left";
          ctx.textBaseline = l.baseline || "top";
          const pad = 4;
          const metrics = ctx.measureText(l.text);
          const w = metrics.width + pad*2;
          const h = parseInt((l.font||"11px").match(/\d+/)?.[0] || "11", 10) + pad*2;
          ctx.fillStyle = l.bg || "rgba(255,255,255,0.7)";
          ctx.fillRect((l.x||10)-pad, (l.y||10)-pad, w, h);
          ctx.fillStyle = l.fill || "#111";
          ctx.fillText(l.text, l.x||10, l.y||10);
        }
        ctx.restore();
      }
    }

    // ===================== buildMap_ver2 (Îã®Ïùº cellObj) =====================
    window.buildMap_ver2 = function(cellObj){
      const rectList = R(), labelList = L();
      const SCALE = 5;

      rectList.length = 0;
      labelList.length = 0;

      const cellname = cellObj.cellname || "(unknown)";
      const libname  = cellObj.libname  || "(unknown)";

      const Z = { bbox:0, subblock:10, mask:20, metal:30, pin:40, label:1000 };

      function parseMetalIndex(layer=""){
        const L = String(layer).toLowerCase().replace(/\s+/g,"");
        let m = L.match(/metal\s*([0-9]+)/); if (m && m[1]) return parseInt(m[1],10);
        m = L.match(/^m\s*([0-9]+)$/);       if (m && m[1]) return parseInt(m[1],10);
        return null;
      }
      function metalZ(layer){
        const idx = parseMetalIndex(layer);
        const base = Z.metal, step = 2;
        return (idx != null) ? base + (idx-1)*step : base;
      }
      function metalColor(layer){
        if (!layer) return "rgba(0,0,255,0.35)";
        const L = String(layer).toLowerCase();
        if (L.includes('metal1')) return "rgba(0,128,255,0.35)";
        if (L.includes('metal2')) return "rgba(255,128,0,0.35)";
        if (L.includes('metal3')) return "rgba(160,32,240,0.35)";
        return "rgba(0,0,255,0.35)";
      }
      function pushRectFromXY(xy,color,label,kind,meta={}){
        if (!xy || xy.length!==2) return;
        const ox = xy[0][0]*SCALE, oy=xy[0][1]*SCALE;
        const w  = (xy[1][0]-xy[0][0])*SCALE;
        const h  = (xy[1][1]-xy[0][1])*SCALE;
        if (meta.z == null) meta.z = Z[kind] ?? 0;
        rectList.push([ox, -oy, w, -h, color, label, true, kind, meta]);
        labelList.push({
          x:ox+2, y:-(oy)-2, text:label,
          font:"11px sans-serif", fill:"#222",
          align:"left", baseline:"top",
          z:Z.label, lz:meta.z, kind
        });
      }

      // 0) bbox
      if (Array.isArray(cellObj.bbox) && cellObj.bbox.length===2){
        const [p0,p1] = cellObj.bbox;
        const ox=p0[0]*SCALE, oy=p0[1]*SCALE;
        const w=(p1[0]-p0[0])*SCALE, h=(p1[1]-p0[1])*SCALE;
        rectList.push([ox,-oy,w,-h,"rgba(128,128,128,0.12)","bbox",true,"bbox",{kind:"bbox",z:Z.bbox}]);
      }

      // 1) metals
      if (Array.isArray(cellObj.metals)){
        cellObj.metals.forEach((m,i)=>{
          const color = metalColor(m.layer);
          const label = `${m.layer || "Metal"} #${i}`;
          pushRectFromXY(m.xy, color, label, "metal", {layer:m.layer||"", z:metalZ(m.layer)});
        });
      }

      // 2) pins
      if (Array.isArray(cellObj.pins)){
        cellObj.pins.forEach(p=>{
          const name = p.name || p.netname || "pin";
          pushRectFromXY(p.xy, "rgba(0,200,0,0.55)", String(name), "pin", {
            layer:p.layer||"", netname:p.netname||"", z:Z.pin
          });
        });
      }

      // 3) subblocks
      if (Array.isArray(cellObj.subblocks)){
        cellObj.subblocks.forEach(sb=>{
          const instName = sb.name || "(inst)";
          const instLib  = sb.libname || "";
          const instCell = sb.cellname || "";
          const xy       = sb.xy || [0,0];
          const tr       = sb.transform || "R0";

          const bbox = sb.bbox || cellObj.__libBBoxes?.[`${instLib}:${instCell}`];
          if (!bbox || bbox.length!==2){ console.warn("subblock bbox missing; skip:", sb); return; }

          const w=(bbox[1][0]-bbox[0][0])*SCALE, h=(bbox[1][1]-bbox[0][1])*SCALE;
          let ox=xy[0]*SCALE, oy=xy[1]*SCALE; if (tr==="MX") oy -= h;

          rectList.push([ox,-oy,w,-h,"rgba(0,0,0,1.0)",instName,true,"subblock",{
            kind:"subblock", instName, instLib, instCell, transform:tr, z:Z.subblock
          }]);

          L().push({ x:ox+2, y:-(oy)-2,  text:`Inst: ${instName}`, font:"12px sans-serif", fill:"#000",
            align:"left", baseline:"top", z:Z.label, lz:Z.subblock, kind:"subblock" });
          L().push({ x:ox+2, y:-(oy)-16, text:`Lib: ${instLib}, Cell: ${instCell}`, font:"11px sans-serif", fill:"#444",
            align:"left", baseline:"top", z:Z.label, lz:Z.subblock, kind:"subblock" });
        });
      }

      // 4) HUD ÎùºÎ≤®
      L().push({ x:10, y:10, text:`cellname: ${cellname}`, font:"bold 14px sans-serif", fill:"#111", align:"left", baseline:"top", z:Z.label });
      L().push({ x:10, y:28, text:`libname: ${libname}`,   font:"12px sans-serif",      fill:"#333", align:"left", baseline:"top", z:Z.label });

      // === Î™®Îëê Ï±ÑÏõ†Îã§Î©¥: Ï§å-Ìà¨-Ìïè ÌõÑ Ïù¥Î≤§Ìä∏ ÏïåÎ¶º ===
      ensureInit();
      zoomToFit(20);
      window.dispatchEvent(new CustomEvent('layout:ready'));
    };

    // ===================== Ïû¨Î†åÎçî Ìä∏Î¶¨Í±∞ =====================
    window.addEventListener('layout:ready', ()=>{
      buildLayerToggles('layerToggles');
      redraw();
    });

    // ===================== ÎìúÎûòÍ∑∏/Ìú† Ïù∏ÌÑ∞ÎûôÏÖò =====================
    (function attachPanZoom(){
      ensureInit(); const canvas=layoutState.canvas, ctx=layoutState.ctx; if (!canvas||!ctx) return;
      let lastX = canvas.width/2, lastY = canvas.height/2;
      let dragStart=null, dragged=false;
      canvas.addEventListener('mousedown', (e)=>{
        document.body.style.userSelect='none';
        lastX=e.offsetX; lastY=e.offsetY;
        dragStart = ctx.transformedPoint(lastX,lastY);
        dragged=false;
      });
      canvas.addEventListener('mousemove', (e)=>{
        lastX=e.offsetX; lastY=e.offsetY; dragged=true;
        if (dragStart){
          const pt = ctx.transformedPoint(lastX,lastY);
          ctx.translate(pt.x - dragStart.x, pt.y - dragStart.y);
          redraw();
        }
      });
      canvas.addEventListener('mouseup', ()=>{
        dragStart=null;
      });
      const scaleFactor=1.1;
      function zoom(clicks){
        const pt = ctx.transformedPoint(lastX,lastY);
        ctx.translate(pt.x,pt.y);
        const factor = Math.pow(scaleFactor, clicks);
        ctx.scale(factor,factor);
        ctx.translate(-pt.x,-pt.y);
        redraw();
      }
      function handleScroll(evt){
        const delta = evt.wheelDelta ? evt.wheelDelta/40 : (evt.detail ? -evt.detail : 0);
        if (delta){ zoom(delta); evt.preventDefault(); }
        return false;
      }
      canvas.addEventListener('DOMMouseScroll', handleScroll, false);
      canvas.addEventListener('mousewheel', handleScroll, false);
    })();

    // ===================== Layout Draw Î≤ÑÌäº: ÏÑúÎ≤Ñ Ìò∏Ï∂ú ÌõÑ Î†åÎçî =====================
    document.getElementById("layoutDrawBtn").addEventListener("click", async function () {
      const form = document.getElementById("editForm");
      const urlObj = new URL(form.action, window.location.origin);
      const basePath = urlObj.pathname; // "/main/:id/edit"
      const pathParam = urlObj.searchParams.get('path') || '/';
      const drawUrl = `${basePath}/draw?path=${encodeURIComponent(pathParam)}`;

      const formData = new FormData(form);
      const cellFromInput = (document.getElementById("cellNameInput").value || '').trim();
      const libFromInput  = (document.getElementById("yamlFileInput").value  || '').trim();
      formData.set('cellname', cellFromInput);
      formData.set('libname',  libFromInput);

      const body = new URLSearchParams(); for (const p of formData) body.append(p[0], p[1]);

      const msgEl = document.getElementById("message");
      try {
        const response = await fetch(drawUrl, {
          method:'POST', headers:{'Content-Type':'application/x-www-form-urlencoded'},
          body, credentials:'include'
        });
        const result = await response.json();
        console.log("üéØ Layout Draw ÏùëÎãµ:", result);

        if (response.ok && result.success && result.drawObjectDoc){
          const cellObj = result.drawObjectDoc;
          const libName  = cellObj.libname  || result.resolvedLibname  || 'logic_generated';
          const cellName = cellObj.cellname || result.resolvedCellname || '(unknown cell)';
          msgEl.innerText = `‚úÖ Layout Draw ÏÑ±Í≥µ: ${libName} / ${cellName}`;

          // Ï∫îÎ≤ÑÏä§ Îç∞Ïù¥ÌÑ∞ Ï¥àÍ∏∞Ìôî ÌõÑ build & draw
          layoutState.rectList.length = 0;
          layoutState.labelList.length = 0;
          buildMap_ver2(cellObj);   // ÎÇ¥Î∂ÄÏóêÏÑú zoomToFit + layout:ready Î∞úÏÉù
        } else {
          msgEl.innerText = result?.message || '‚ö†Ô∏è Layout Draw Ïã§Ìå®';
        }
      } catch (err) {
        console.error("‚ùå Layout Draw Ïò§Î•ò:", err);
        msgEl.innerText = "ÏÑúÎ≤Ñ Ïò§Î•òÎ°ú LayoutÏùÑ Í∑∏Î¶¥ Ïàò ÏóÜÏäµÎãàÎã§.";
      }
    });

    // ===================== Save(Ï†ÄÏû•) AJAXÎäî Í∏∞Ï°¥ Î°úÏßÅ Ïú†ÏßÄ =====================
    document.getElementById("editForm").addEventListener("submit", async function (e) {
      e.preventDefault();
      const form = e.target;
      const formData = new FormData(form);
      const data = new URLSearchParams(); for (const p of formData) data.append(p[0], p[1]);

      const msg = document.getElementById("message");
      try{
        const response = await fetch(form.action, {
          method:'PUT', headers:{'Content-Type':'application/x-www-form-urlencoded'},
          body:data, credentials:'include'
        });
        const result = await response.json();
        if (response.ok && result.success){
          const generateSwitch = document.getElementById("generateSwitch");
          msg.innerText = (generateSwitch && generateSwitch.checked) ? "Generate ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§." : "Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§.";
        }else{
          msg.innerText = "Ï†ÄÏû•Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.";
        }
        msg.style.opacity=1;
        setTimeout(()=>{ msg.style.transition="opacity 0.5s"; msg.style.opacity=0;}, 2000);
      }catch(err){
        console.error(err);
        msg.innerText="Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.";
        msg.style.opacity=1;
        setTimeout(()=>{ msg.style.transition="opacity 0.5s"; msg.style.opacity=0;}, 2000);
      }
    });

    // ===================== Î°úÍ∑∏ Ìè¥ÎßÅ (Í∏∞Ï°¥ Ïú†ÏßÄ) =====================
    setInterval(async () => {
      try {
        const fileId = "<%= file._id %>";
        const res = await fetch(`/main/${fileId}/edit/logs`, { credentials:'include' });
        if (!res.ok) return;
        const text = await res.text();
        try{
          const result = JSON.parse(text);
          document.getElementById("terminal").innerText = result.log;
        }catch(e){ console.error("JSON ÌååÏã± ÏóêÎü¨:", e); }
      } catch (e) { console.error("Î°úÍ∑∏ Ìè¥ÎßÅ ÏóêÎü¨:", e); }
    }, 2000);

  });
  </script>




  

  <!-- ==================================================================================================== -->

  <%- include('./include/_footer') %>